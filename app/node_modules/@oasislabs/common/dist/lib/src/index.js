var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
export { default as cbor } from './cbor';
import * as bytes from './bytes';
export { LocalStorage, DummyStorage } from './db';
export { sleep } from './utils';
/**
 * Lighteweight wrapper for bytes with an easy hex conversion.
 */
var Bytes = /** @class */ (function () {
    // This takes `expectedLength` because Typescript doesn't have `abstract static`.
    function Bytes(expectedLength, repr) {
        if (typeof repr === 'string') {
            this._bytes = bytes.parseHex(repr);
        }
        else {
            this._bytes = repr;
        }
        if (this._bytes.length !== expectedLength) {
            throw new Error("invalid length: expected " + expectedLength + " bytes, got " + this._bytes.length + " bytes");
        }
    }
    Object.defineProperty(Bytes.prototype, "bytes", {
        get: function () {
            return this._bytes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Bytes.prototype, "hex", {
        get: function () {
            if (typeof this._hex === 'undefined') {
                this._hex = bytes.toHex(this._bytes);
            }
            return this._hex;
        },
        enumerable: true,
        configurable: true
    });
    return Bytes;
}());
export { Bytes };
/**
 * A 20-byte Oasis account address. May be hex-encoded.
 */
var Address = /** @class */ (function (_super) {
    __extends(Address, _super);
    function Address(repr) {
        return _super.call(this, 20, repr) || this;
    }
    return Address;
}(Bytes));
export { Address };
/**
 * A 16-byte Oasis account balance.
 * JS `Number`s do not have enough precision to hold a 128-bit integer
 * so you should prefer to encode as hex or pass a Uint8Array directly.
 */
var Balance = /** @class */ (function (_super) {
    __extends(Balance, _super);
    function Balance(repr) {
        var _this = this;
        var balanceBytes = new Uint8Array(16); // 128 bit
        if (typeof repr === 'number') {
            repr = BigInt(repr);
        }
        if (typeof repr === 'bigint') {
            for (var i = 0; i < balanceBytes.length; i++) {
                balanceBytes[balanceBytes.length - i - 1] = Number((repr >> BigInt(i * 8)) & BigInt(0xff));
            }
        }
        else if (typeof repr === 'string') {
            var parsed = bytes.parseHex(repr);
            balanceBytes.set(parsed, balanceBytes.length - parsed.length);
        }
        else {
            balanceBytes = repr;
        }
        _this = _super.call(this, 16, balanceBytes) || this;
        return _this;
    }
    return Balance;
}(Bytes));
export { Balance };
export { bytes };
//# sourceMappingURL=index.js.map